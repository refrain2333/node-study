# 变量与作用域 - 练习题答案

## 练习1：修复变量作用域问题

### 问题描述
```javascript
// 原始有问题的代码
for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log("i =", i); // 都输出 3
    }, 100);
}
```

### 问题分析
使用 `var` 声明的变量 `i` 是函数作用域，在循环结束后 `i` 的值为 3。由于闭包的特性，所有的 `setTimeout` 回调函数都引用了同一个变量 `i`，所以都输出 3。

### 解决方案

#### 方案1：使用 let（推荐）
```javascript
for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log("修复后 i =", i); // 输出 0, 1, 2
    }, 100);
}
```

**原理：** `let` 声明的变量具有块级作用域，每次循环都会创建一个新的块级作用域，每个 `setTimeout` 回调函数都绑定到对应循环迭代的 `i` 值。

#### 方案2：使用 IIFE
```javascript
for (var i = 0; i < 3; i++) {
    (function(index) {
        setTimeout(() => {
            console.log("IIFE i =", index); // 输出 0, 1, 2
        }, 100);
    })(i);
}
```

**原理：** 立即执行函数为每个循环迭代创建了一个新的作用域，将当前的 `i` 值作为参数传递并保存在 `index` 变量中。

#### 方案3：使用 bind
```javascript
for (var i = 0; i < 3; i++) {
    setTimeout(function(index) {
        console.log("bind i =", index); // 输出 0, 1, 2
    }.bind(null, i), 100);
}
```

## 练习2：创建安全的计数器

### 问题描述
创建一个具有私有状态的计数器，外部无法直接访问内部的计数值。

### 解决方案

```javascript
function createSafeCounter() {
    let count = 0; // 私有变量，外部无法直接访问
    
    return {
        increment() {
            count++;
            return count;
        },
        decrement() {
            count--;
            return count;
        },
        getCount() {
            return count;
        },
        reset() {
            count = 0;
            return count;
        }
    };
}

// 使用示例
const counter = createSafeCounter();

console.log("初始计数:", counter.getCount()); // 0
console.log("增加后:", counter.increment());   // 1
console.log("增加后:", counter.increment());   // 2
console.log("减少后:", counter.decrement());   // 1
console.log("当前计数:", counter.getCount());  // 1
console.log("重置后:", counter.reset());       // 0
```

### 工作原理

1. **闭包机制：** `createSafeCounter` 函数返回一个对象，该对象的方法可以访问函数内部的 `count` 变量
2. **私有性：** 外部代码无法直接访问 `count` 变量，只能通过返回对象的方法来操作
3. **状态保持：** 每次调用 `createSafeCounter()` 都会创建一个新的 `count` 变量，互不干扰

### 验证私有性

```javascript
const counter1 = createSafeCounter();
const counter2 = createSafeCounter();

counter1.increment(); // counter1: 1
counter1.increment(); // counter1: 2
counter2.increment(); // counter2: 1

console.log(counter1.getCount()); // 2
console.log(counter2.getCount()); // 1
// 两个计数器互不影响，证明了私有性
```

## 进阶练习题答案

### 练习1：创建计数器工厂

```javascript
function createCounterFactory() {
    const counters = new Map(); // 存储所有计数器
    
    return {
        createCounter(name) {
            if (counters.has(name)) {
                throw new Error(`计数器 ${name} 已存在`);
            }
            
            let count = 0;
            const counter = {
                increment() {
                    return ++count;
                },
                decrement() {
                    return --count;
                },
                getCount() {
                    return count;
                },
                reset() {
                    count = 0;
                    return count;
                }
            };
            
            counters.set(name, counter);
            return counter;
        },
        
        getCounter(name) {
            return counters.get(name);
        },
        
        getAllCounters() {
            return Array.from(counters.keys());
        },
        
        removeCounter(name) {
            return counters.delete(name);
        }
    };
}

// 使用示例
const counterFactory = createCounterFactory();

const counterA = counterFactory.createCounter("A");
const counterB = counterFactory.createCounter("B");

console.log("计数器 A:", counterA.increment()); // 1
console.log("计数器 A:", counterA.increment()); // 2
console.log("计数器 B:", counterB.increment()); // 1

console.log("所有计数器:", counterFactory.getAllCounters()); // ['A', 'B']
console.log("计数器 A 的值:", counterFactory.getCounter("A").getCount()); // 2
```

### 练习2：实现缓存系统

```javascript
function createCache() {
    const cache = new Map();
    const maxSize = 100;
    
    return {
        set(key, value) {
            if (cache.size >= maxSize) {
                // 删除最旧的条目（LRU 策略）
                const firstKey = cache.keys().next().value;
                cache.delete(firstKey);
            }
            cache.set(key, value);
            return this; // 支持链式调用
        },
        
        get(key) {
            return cache.get(key);
        },
        
        has(key) {
            return cache.has(key);
        },
        
        delete(key) {
            return cache.delete(key);
        },
        
        clear() {
            cache.clear();
        },
        
        size() {
            return cache.size;
        },
        
        keys() {
            return Array.from(cache.keys());
        },
        
        values() {
            return Array.from(cache.values());
        }
    };
}

// 使用示例
const cache = createCache();

cache.set("user1", { name: "张三", age: 25 })
     .set("user2", { name: "李四", age: 30 })
     .set("config", { theme: "dark", lang: "zh" });

console.log("user1:", cache.get("user1"));
console.log("缓存大小:", cache.size());
console.log("所有键:", cache.keys());
console.log("是否有 user1:", cache.has("user1"));

// 链式调用
cache.delete("user1").set("user3", { name: "王五", age: 28 });
console.log("删除后大小:", cache.size());
```

## 常见问题解答

### Q1: 为什么 let 能解决循环中的闭包问题？

A: `let` 声明的变量具有块级作用域，每次循环迭代都会创建一个新的块级作用域，每个作用域都有自己的 `i` 变量副本。而 `var` 声明的变量是函数作用域，所有迭代共享同一个变量。

### Q2: 闭包会导致内存泄漏吗？

A: 闭包本身不会导致内存泄漏，但如果闭包引用了大量不必要的数据，可能会阻止垃圾回收。应该及时清理不需要的引用。

### Q3: const 声明的对象属性可以修改吗？

A: 可以。`const` 只保护变量引用不被修改，但可以修改对象内部的属性。如果需要完全不可变，可以使用 `Object.freeze()`。

### Q4: 如何判断一个变量是否在作用域内？

A: 可以使用 `typeof` 检查变量是否存在，或者使用 try-catch 捕获 ReferenceError。

```javascript
function checkVariable() {
    if (typeof someVar !== 'undefined') {
        console.log('变量存在');
    } else {
        console.log('变量不存在');
    }
}
```

## 总结

通过这些练习，你应该掌握了：

1. **闭包的应用**：创建私有变量和方法
2. **作用域的理解**：块级作用域 vs 函数作用域
3. **实际场景的解决方案**：循环闭包问题、数据封装
4. **最佳实践**：使用 const/let、避免全局污染

这些概念是现代 JavaScript 开发的基础，将在后续的异步编程、模块化开发中发挥重要作用。