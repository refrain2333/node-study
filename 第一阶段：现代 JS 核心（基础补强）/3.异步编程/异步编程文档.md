# 异步编程基础文档

## 概述
异步编程是 JavaScript 的核心特性，用于处理不阻塞主线程的操作。Promise 是 ES6 引入的异步编程解决方案，提供更清晰的异步代码结构。

## Promise 基本概念

### 创建 Promise
```javascript
const promise = new Promise((resolve, reject) => {
    // 异步操作
    setTimeout(() => {
        if (Math.random() > 0.5) {
            resolve("成功");
        } else {
            reject("失败");
        }
    }, 1000);
});
```

### 使用 Promise
```javascript
promise
    .then(result => {
        console.log("成功:", result);
    })
    .catch(error => {
        console.log("失败:", error);
    });
```

## Promise 状态

Promise 有三种状态：
- **pending**: 初始状态，既不是成功也不是失败
- **fulfilled**: 操作成功完成
- **rejected**: 操作失败

```javascript
const pending = new Promise(() => {});           // pending
const fulfilled = Promise.resolve("成功");        // fulfilled
const rejected = Promise.reject("失败");          // rejected
```

## Promise 链式调用

```javascript
createAsyncTask("第一步", 500)
    .then(result => {
        console.log(result);
        return createAsyncTask("第二步", 300);
    })
    .then(result => {
        console.log(result);
        return "完成";
    })
    .catch(error => {
        console.log("错误:", error);
    });
```

## Promise 静态方法

### Promise.resolve()
立即返回一个已解决的 Promise。

### Promise.reject()
立即返回一个已拒绝的 Promise。

### Promise.all()
所有 Promise 都成功时返回结果数组，任何一个失败则立即拒绝。

```javascript
Promise.all([promise1, promise2, promise3])
    .then(results => console.log(results))
    .catch(error => console.log(error));
```

### Promise.race()
返回第一个完成的 Promise（无论成功或失败）。

### Promise.allSettled()
等待所有 Promise 完成，返回包含每个 Promise 状态的对象数组。

## 错误处理

### 使用 catch()
```javascript
promise
    .then(result => console.log(result))
    .catch(error => console.log("错误:", error));
```

### then() 的第二个参数
```javascript
promise.then(
    result => console.log(result),
    error => console.log("错误:", error)
);
```

### 链式错误处理
```javascript
Promise.resolve("开始")
    .then(() => {
        throw new Error("出错");
    })
    .catch(error => {
        console.log("处理错误:", error);
        return "继续";
    })
    .then(result => console.log(result));
```

## 实际应用场景

### API 调用
```javascript
function fetchUser(id) {
    return new Promise((resolve, reject) => {
        // 模拟 API 请求
        setTimeout(() => {
            if (id > 0) {
                resolve({ id, name: `用户${id}` });
            } else {
                reject(new Error("无效ID"));
            }
        }, 300);
    });
}
```

### 链式调用
```javascript
fetchUser(1)
    .then(user => {
        console.log("用户:", user);
        return fetchUserPosts(user.id);
    })
    .then(posts => {
        console.log("文章:", posts);
    })
    .catch(error => console.log("错误:", error));
```

### 并行请求
```javascript
Promise.all([fetchUser(1), fetchUserPosts(1)])
    .then(([user, posts]) => {
        console.log("用户:", user);
        console.log("文章:", posts);
    });
```

## 练习题

### 练习1：延迟函数
```javascript
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

delay(1000).then(() => console.log("延迟执行"));
```

### 练习2：重试机制
```javascript
function withRetry(fn, maxRetries = 3, delayMs = 1000) {
    return new Promise((resolve, reject) => {
        let attempts = 0;
        
        function attempt() {
            fn()
                .then(resolve)
                .catch(error => {
                    attempts++;
                    if (attempts >= maxRetries) {
                        reject(new Error(`重试失败: ${error.message}`));
                    } else {
                        setTimeout(attempt, delayMs);
                    }
                });
        }
        
        attempt();
    });
}
```

### 练习3：超时机制
```javascript
function withTimeout(promise, timeoutMs) {
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("超时")), timeoutMs);
    });
    
    return Promise.race([promise, timeoutPromise]);
}
```

### 练习4：批量处理
```javascript
function batchProcess(items, processor, batchSize = 3) {
    const results = [];
    
    return new Promise((resolve) => {
        function processBatch(startIndex) {
            const batch = items.slice(startIndex, startIndex + batchSize);
            
            if (batch.length === 0) {
                resolve(results);
                return;
            }
            
            const promises = batch.map((item, index) => {
                return processor(item).then(result => {
                    results[startIndex + index] = result;
                });
            });
            
            Promise.all(promises).then(() => {
                processBatch(startIndex + batchSize);
            });
        }
        
        processBatch(0);
    });
}
```

## 总结
- Promise 让异步代码更易读，避免回调地狱。
- 使用链式调用处理异步流程。
- 利用静态方法处理多个异步操作。
- 始终添加错误处理。