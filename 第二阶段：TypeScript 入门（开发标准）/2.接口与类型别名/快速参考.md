## 接口与类型别名 - 快速参考

### 对比表

| 特性 | Interface | Type |
|-----|-----------|------|
| 声明合并 | ✓ | ✗ |
| 继承 | `extends` | `&` |
| 实现 | `implements` | 不支持 |
| 递归定义 | ✓ | ✓ |
| 基础类型别名 | ✗ | ✓ |
| 联合类型 | ✗ | ✓ |
| 元组 | ✓ | ✓ |

### 常用模式

```typescript
// 接口继承
interface Animal { name: string; }
interface Dog extends Animal { bark(): void; }

// 类型交集
type Named = { name: string };
type Aged = { age: number };
type Person = Named & Aged;

// 接口声明合并
interface Window { myVar: string; }
interface Window { myOtherVar: number; } // 自动合并

// 函数签名
interface Callable {
  (x: number): number;
}

type CallableType = (x: number) => number;
```

### 何时使用

- **Interface**: 描述对象形状、类契约
- **Type**: 所有情况，尤其是联合类型、元组、基础类型

---

## 泛型 - 快速参考

### 基础语法

```typescript
// 函数泛型
function id<T>(x: T): T { return x; }

// 类泛型
class Box<T> { value: T; }

// 接口泛型
interface Container<T> { item: T; }
```

### 约束

```typescript
// 单个约束
<T extends string>

// 多个约束
<T extends string | number>

// 对象约束
<T extends { x: number }>

// keyof 约束
<K extends keyof T>
```

### 内置工具类型

| 工具 | 作用 |
|-----|------|
| `Partial<T>` | 所有属性可选 |
| `Required<T>` | 所有属性必须 |
| `Pick<T, K>` | 选择属性 |
| `Omit<T, K>` | 排除属性 |
| `Record<K, V>` | 映射类型 |
| `Readonly<T>` | 只读 |

### 条件类型

```typescript
// 语法
T extends U ? X : Y

// 例子
type IsString<T> = T extends string ? true : false;
type Unwrap<T> = T extends Promise<infer U> ? U : T;
```

---

## 类与装饰器 - 快速参考

### 访问修饰符

```typescript
class Example {
  public prop = 1;      // 任何地方访问（默认）
  protected prop = 1;   // 子类访问
  private prop = 1;     // 仅此类访问
  
  readonly prop = 1;    // 只读
}
```

### 继承和多态

```typescript
class Animal {
  move(): void { console.log("Moving"); }
}

class Dog extends Animal {
  move(): void { console.log("Running"); } // 重写
  bark(): void { console.log("Woof"); }    // 新方法
}

// 抽象类
abstract class Base {
  abstract method(): void; // 必须实现
  concrete(): void {}      // 可选实现
}
```

### 常用设计模式

| 模式 | 用途 |
|-----|------|
| 工厂 | 对象创建抽象 |
| 观察者 | 事件系统 |
| 策略 | 算法选择 |
| 装饰器 | 动态添加功能 |
| 单例 | 全局唯一实例 |

---

## VS JavaScript

### 类型安全对比

```javascript
// JS：运行时才发现错误
function add(a, b) {
  return a + b;
}
add("hello", "world"); // 可能有问题但不报错

// TS：编译时发现
function add(a: number, b: number): number {
  return a + b;
}
add("hello", "world"); // ✗ 编译错误！
```

### 接口/类型 vs 对象

```javascript
// JS：灵活但无约束
const user = { name: "张三", age: 25, email: "..." };

// TS：类型约束
interface User {
  name: string;
  age: number;
  email?: string; // 可选
}
const user: User = { name: "张三", age: 25 };
```

### 泛型 vs 动态类型

```javascript
// JS：失去类型信息
function identity(x) { return x; }
const result = identity(42);
// result 是什么类型？不知道

// TS：类型信息保留
function identity<T>(x: T): T { return x; }
const result = identity(42); // result 是 number
```

---

## 编译提示

### 常见错误

**1. 属性不存在**
```typescript
const user = { name: "张三" };
console.log(user.email); // ✗ 属性 'email' 不存在
```

**2. 类型不匹配**
```typescript
const x: number = "hello"; // ✗ 不能将 string 分配给 number
```

**3. 缺少实现**
```typescript
abstract class Base {
  abstract method(): void;
}

class Child extends Base {
  // ✗ 必须实现 method()
}
```

### 修复策略

| 问题 | 解决方案 |
|-----|--------|
| 属性不存在 | 检查类型定义或使用可选属性 `?` |
| 类型不匹配 | 使用类型转换或类型守卫 |
| 缺少实现 | 实现所有抽象方法 |

---

## 最佳实践

### ✅ 应该做的

```typescript
// 1. 明确的类型签名
interface API {
  getData(id: number): Promise<Data>;
}

// 2. 可复用的泛型
class Repository<T extends { id: number }> {
  // T 有 id 属性的约束
}

// 3. 接口定义边界
interface Props {
  name: string;
  age?: number;
}

// 4. 类的单一职责
class UserService {
  // 只负责用户相关业务
}
```

### ❌ 避免的

```typescript
// 1. 过度使用 any
const data: any = ...;

// 2. 忘记访问修饰符
class Example {
  // 应该是 private
  internalState = {};
}

// 3. 复杂的嵌套泛型
type TooComplex<T> = T extends Promise<infer U extends { x: infer V }>
  ? V : never; // 难以理解

// 4. 混淆 interface 和 type
interface User { } // 用于对象形状
type UserId = number; // 用于别名
```

---

## 性能提示

### 编译优化

```typescript
// 1. 避免深度递归类型
type DeepRecursive<T> = T extends object ? DeepRecursive<T[keyof T]> : T;

// 2. 使用 infer 简化条件类型
type GetType<T> = T extends Promise<infer U> ? U : T; // ✓ 高效

// 3. 限制泛型复杂度
<T extends keyof U, U extends { [K in T]: any }>
// ✗ 太复杂，简化：
<K extends keyof U, U extends { [key: string]: any }>
```

---

## 进阶阅读

- TypeScript Handbook: https://www.typescriptlang.org/docs/handbook/
- Advanced Types
- Generics Guide
- Utility Types Reference
