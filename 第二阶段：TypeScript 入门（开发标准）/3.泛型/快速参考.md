## 泛型 - 快速参考

### 泛型语法速查表

| 语法 | 用途 | 示例 |
|-----|------|------|
| `<T>` | 单个类型参数 | `function id<T>(x: T): T` |
| `<T, U>` | 多个类型参数 | `function pair<T, U>(a: T, b: U)` |
| `<T extends Type>` | 约束 | `<T extends string \| number>` |
| `<T = Type>` | 默认值 | `<T = any>` |
| `infer U` | 类型推断 | `T extends Promise<infer U>` |

### 常用泛型函数

```typescript
// 恒等函数
function identity<T>(arg: T): T { return arg; }

// 数组长度
function getLength<T extends { length: number }>(arg: T): number {
  return arg.length;
}

// 对象属性获取
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// 条件返回
function isBigger<T extends number | string>(
  value: T,
  limit: T
): boolean {
  return value > limit;
}
```

### 泛型类和接口

```typescript
// 泛型类
class Box<T> {
  constructor(public value: T) {}
  getValue(): T { return this.value; }
}

// 泛型接口
interface Loader<T> {
  load(): Promise<T>;
}

// 泛型类型别名
type Container<T> = {
  value: T;
  map<U>(fn: (x: T) => U): Container<U>;
};
```

### 内置工具类型 - 对象类型

| 工具 | 输入 | 输出 | 用途 |
|-----|------|------|------|
| `Partial<T>` | `{x:number}` | `{x?:number}` | 所有可选 |
| `Required<T>` | `{x?:number}` | `{x:number}` | 所有必须 |
| `Pick<T,K>` | 对象和键 | 子对象 | 选择属性 |
| `Omit<T,K>` | 对象和键 | 子对象 | 排除属性 |
| `Readonly<T>` | `{x:number}` | `{readonly x:number}` | 所有只读 |

### 内置工具类型 - 映射

| 工具 | 用途 | 示例 |
|-----|------|------|
| `Record<K, V>` | 键值映射 | `Record<'a' \| 'b', string>` |
| `Extract<T, U>` | 取交集 | `Extract<'a' \| 'b', 'a'>` → `'a'` |
| `Exclude<T, U>` | 取差集 | `Exclude<'a' \| 'b', 'a'>` → `'b'` |

### 条件类型模式

```typescript
// 模式 1: 类型守卫
type IsArray<T> = T extends any[] ? true : false;

// 模式 2: 提取嵌套类型
type Flatten<T> = T extends Array<infer U> ? U : T;

// 模式 3: 联合类型分布
type StringToNumber<T> = T extends string ? number : T;

// 模式 4: 递归类型
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object
    ? DeepReadonly<T[K]>
    : T[K];
};
```

### 约束模式

```typescript
// 对象约束
function mergeObjects<T extends object, U extends object>(
  a: T,
  b: U
): T & U {
  return { ...a, ...b };
}

// 数组约束
function getFirstElement<T extends any[]>(arr: T): T[0] {
  return arr[0];
}

// 属性约束
function getPropertyType<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// 构造函数约束
interface Constructor<T> {
  new (): T;
}

function getInstance<T>(ctor: Constructor<T>): T {
  return new ctor();
}
```

---

## 类与装饰器 - 快速参考

### 类语法速查

```typescript
// 基础类
class Animal {
  name: string = "动物";
  
  constructor(name: string) {
    this.name = name;
  }
  
  move() { console.log("移动"); }
}

// 继承
class Dog extends Animal {
  move() { console.log("跑动"); }
  bark() { console.log("汪"); }
}

// 实现接口
class Cat implements Movable {
  move() { }
}
```

### 访问修饰符

```typescript
class Example {
  public prop = 1;      // 所有地方
  protected prop = 2;   // 此类和子类
  private prop = 3;     // 仅此类
  
  readonly ro = 4;      // 不可修改
  static stat = 5;      // 类静态
}

// 参数属性（快速初始化）
class Point {
  constructor(public x: number, public y: number) {}
}
// 等同于：
class Point {
  x: number;
  y: number;
  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}
```

### 继承模式

| 模式 | 用途 | 示例 |
|-----|------|------|
| 直接继承 | 子类化 | `class Dog extends Animal` |
| 接口实现 | 契约定义 | `class Dog implements Movable` |
| 抽象类 | 模板方法 | `abstract class Base { abstract method(); }` |
| Mixin | 组合多个类 | `applyMixins(Child, [Base1, Base2])` |

### 常用设计模式

#### 工厂模式
```typescript
class UserFactory {
  static create(type: 'admin' | 'user'): User {
    return type === 'admin' ? new AdminUser() : new RegularUser();
  }
}
```

#### 单例模式
```typescript
class Logger {
  private static instance: Logger;
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
}
```

#### 观察者模式
```typescript
class Subject<T> {
  private observers: Observer<T>[] = [];
  
  attach(observer: Observer<T>) {
    this.observers.push(observer);
  }
  
  notify(data: T) {
    this.observers.forEach(o => o.update(data));
  }
}
```

#### 策略模式
```typescript
interface Strategy { execute(): void; }
class Context {
  constructor(private strategy: Strategy) {}
  run() { this.strategy.execute(); }
}
```

### 装饰器（Experimental）

```typescript
// 启用：tsconfig.json 中 "experimentalDecorators": true

// 类装饰器
function Entity(target: Function) {
  target.prototype.isEntity = true;
}

// 方法装饰器
function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  descriptor.value = function(...args: any[]) {
    console.log(`调用 ${propertyKey}:`, args);
    return original.apply(this, args);
  };
}

@Entity
class User {
  @Log
  getName() { return "张三"; }
}
```

---

## Python vs TypeScript 对照

### 对象和类

```python
# Python
class User:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
    
    def get_info(self) -> str:
        return f"{self.name} 今年 {self.age} 岁"
```

```typescript
// TypeScript
class User {
  constructor(public name: string, public age: number) {}
  
  getInfo(): string {
    return `${this.name} 今年 ${this.age} 岁`;
  }
}
```

### 泛型

```python
# Python
from typing import TypeVar, Generic

T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, value: T):
        self.value = value
    
    def get(self) -> T:
        return self.value
```

```typescript
// TypeScript
class Box<T> {
  constructor(private value: T) {}
  
  get(): T {
    return this.value;
  }
}
```

### 接口/协议

```python
# Python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> None: ...

class Circle:
    def draw(self) -> None:
        print("画圆")

# 任何有 draw 方法的类都实现了 Drawable
```

```typescript
// TypeScript
interface Drawable {
  draw(): void;
}

class Circle implements Drawable {
  draw(): void {
    console.log("画圆");
  }
}
```

---

## 编译验证

### 检查类型

```bash
# 只检查不生成文件
tsc --noEmit

# 检查特定文件
tsc --noEmit file.ts

# 显示详细信息
tsc --noEmit --listFiles
```

### 常见编译错误

| 错误 | 原因 | 修复 |
|-----|------|------|
| Property does not exist | 属性不在类型中 | 检查拼写或添加属性 |
| Cannot assign to readonly | 修改只读属性 | 移除 `readonly` 或使用初始化 |
| No overload matches | 函数参数不匹配 | 检查参数类型 |
| Type is not assignable | 类型不兼容 | 使用类型转换或改变类型 |

---

## 性能和最佳实践

### ✅ 好的实践

```typescript
// 1. 明确的访问修饰符
class User {
  private id: number;
  public name: string;
}

// 2. 使用接口定义契约
interface Repository<T> {
  findById(id: number): T | null;
}

// 3. 约束泛型
function process<T extends { id: number }>(items: T[]): void {}

// 4. 避免过深的继承层级
class A { }
class B extends A { }
class C extends B { } // OK
class D extends C { } // 避免，超过 3 层
```

### ❌ 不好的实践

```typescript
// 1. 过度使用 any
const data: any = ...;

// 2. 深层继承链
class A { }
class B extends A { }
class C extends B { }
class D extends C { }
class E extends D { } // ✗ 太深

// 3. 复杂的泛型嵌套
type ComplexType<T> = T extends Promise<infer U extends { x: infer V }>
  ? V : never; // 难以维护

// 4. 忘记实现接口方法
interface Runnable {
  run(): void;
}

class Worker implements Runnable {
  // ✗ 缺少 run() 方法
}
```

---

## 调试技巧

### 显示推断类型

```typescript
// 技巧：使用 never 让编译器显示推断的类型
const x = "hello";
type X = typeof x; // 显示 string
const _: never = X; // 鼠标悬停可看到 X 的值
```

### 查看生成的 JavaScript

```bash
# 生成到控制台
tsc --listEmittedFiles

# 保留为 .js 文件
tsc file.ts
```

### IDE 提示

- VS Code: Ctrl+Hover 显示类型
- Command Palette: "Go to Definition"
- 右键 → "Peek Definition"

---

## 进阶参考

- TypeScript Handbook: https://www.typescriptlang.org/docs/handbook/
- Advanced Patterns
- Utility Types API
- Conditional Types Guide
