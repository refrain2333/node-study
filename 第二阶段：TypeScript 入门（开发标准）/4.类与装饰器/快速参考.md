## 类与装饰器 - 快速参考

### 类语法速查

```typescript
// 完整的类定义
class User {
  // 属性声明和初始化
  id: number = 0;
  public name: string = ""; // public 是默认的
  private email: string = "";
  protected role: string = "user";
  readonly createdAt: Date = new Date();
  
  // 静态属性和方法
  static count: number = 0;
  static create() { return new User(); }
  
  // 构造函数
  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
    User.count++;
  }
  
  // 方法
  getName(): string { return this.name; }
  
  // getter/setter
  get email(): string { return this._email; }
  set email(value: string) { this._email = value; }
  
  // 参数属性速写
  constructor(public name: string, private id: number) {}
  // 等同于：
  // name: string;
  // id: number;
  // constructor(name: string, id: number) {
  //   this.name = name;
  //   this.id = id;
  // }
}
```

### 访问修饰符详解

| 修饰符 | 此类 | 子类 | 外部 | 用途 |
|--------|------|------|------|------|
| `public` | ✓ | ✓ | ✓ | 公开（默认） |
| `protected` | ✓ | ✓ | ✗ | 仅内部和子类 |
| `private` | ✓ | ✗ | ✗ | 仅此类 |
| `readonly` | ✓ | ✓ | ✓ | 不可修改 |
| `static` | 类级 | 类级 | 类级 | 静态成员 |

### 继承

```typescript
// 基类
class Animal {
  protected name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  move(): void {
    console.log("移动");
  }
}

// 子类
class Dog extends Animal {
  // 继承构造函数
  constructor(name: string) {
    super(name); // 调用父类构造函数
  }
  
  // 重写方法
  move(): void {
    console.log("狗在跑");
  }
  
  // 新方法
  bark(): void {
    console.log("汪");
  }
}
```

### 抽象类

```typescript
// 抽象类不能实例化
abstract class Shape {
  // 抽象属性
  abstract area: number;
  
  // 抽象方法（必须在子类中实现）
  abstract getArea(): number;
  
  // 具体方法（可选实现）
  describe(): void {
    console.log(`面积: ${this.getArea()}`);
  }
}

class Circle extends Shape {
  area: number = 0;
  radius: number;
  
  constructor(radius: number) {
    super();
    this.radius = radius;
  }
  
  // 必须实现抽象方法
  getArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}
```

### 接口实现

```typescript
interface Movable {
  move(): void;
}

interface Drawable {
  draw(): void;
}

class Animation implements Movable, Drawable {
  move(): void { }
  draw(): void { }
}
```

---

## 设计模式速查

### 创建型模式

#### 工厂模式
```typescript
interface User { }
class AdminUser implements User { }
class RegularUser implements User { }

class UserFactory {
  static createUser(type: 'admin' | 'regular'): User {
    return type === 'admin' ? new AdminUser() : new RegularUser();
  }
}
```

#### 单例模式
```typescript
class Logger {
  private static instance: Logger;
  
  private constructor() {}
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
}

const logger1 = Logger.getInstance();
const logger2 = Logger.getInstance();
// logger1 === logger2 ✓
```

#### 生成器模式
```typescript
class UserBuilder {
  private user: any = {};
  
  setName(name: string): UserBuilder {
    this.user.name = name;
    return this;
  }
  
  setEmail(email: string): UserBuilder {
    this.user.email = email;
    return this;
  }
  
  build(): User {
    return this.user;
  }
}

const user = new UserBuilder()
  .setName("张三")
  .setEmail("zhangsan@example.com")
  .build();
```

### 结构型模式

#### 装饰器模式（动态添加功能）
```typescript
interface Component {
  operate(): void;
}

class ConcreteComponent implements Component {
  operate(): void { console.log("基础操作"); }
}

class Decorator implements Component {
  constructor(private component: Component) {}
  
  operate(): void {
    console.log("前置处理");
    this.component.operate();
    console.log("后置处理");
  }
}
```

#### 适配器模式
```typescript
interface ITarget {
  request(): string;
}

class LegacyAdapter implements ITarget {
  request(): string {
    return "适配后的响应";
  }
}
```

### 行为型模式

#### 观察者模式
```typescript
interface Observer<T> {
  update(data: T): void;
}

class Subject<T> {
  private observers: Observer<T>[] = [];
  
  attach(observer: Observer<T>): void {
    this.observers.push(observer);
  }
  
  notify(data: T): void {
    this.observers.forEach(o => o.update(data));
  }
}

// 使用
class ConcreteObserver implements Observer<string> {
  update(data: string): void {
    console.log("收到:" + data);
  }
}

const subject = new Subject<string>();
subject.attach(new ConcreteObserver());
subject.notify("hello");
```

#### 策略模式
```typescript
interface Strategy {
  execute(): void;
}

class ConcreteStrategyA implements Strategy {
  execute(): void { console.log("策略 A"); }
}

class Context {
  constructor(private strategy: Strategy) {}
  
  run(): void {
    this.strategy.execute();
  }
}

new Context(new ConcreteStrategyA()).run();
```

#### 状态模式
```typescript
interface State {
  action(context: Context): void;
}

class HappyState implements State {
  action(context: Context): void {
    console.log("高兴");
    context.setState(new SadState());
  }
}

class SadState implements State {
  action(context: Context): void {
    console.log("难过");
    context.setState(new HappyState());
  }
}

class Context {
  constructor(private state: State) {}
  
  setState(state: State): void {
    this.state = state;
  }
  
  doAction(): void {
    this.state.action(this);
  }
}
```

---

## 装饰器（Decorators）

### 启用装饰器

```json
// tsconfig.json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "reflect-metadata": true
  }
}
```

### 装饰器类型

#### 类装饰器
```typescript
function Entity(constructor: Function) {
  constructor.prototype.isEntity = true;
}

@Entity
class User {
  name: string = "张三";
}

const user = new User();
console.log((user as any).isEntity); // true
```

#### 方法装饰器
```typescript
function Log(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
): PropertyDescriptor {
  const original = descriptor.value;
  
  descriptor.value = function(...args: any[]): any {
    console.log(`调用 ${propertyKey}，参数:`, args);
    return original.apply(this, args);
  };
  
  return descriptor;
}

class Calculator {
  @Log
  add(a: number, b: number): number {
    return a + b;
  }
}

new Calculator().add(1, 2);
// 输出: 调用 add，参数: [1, 2]
// 输出: 3
```

#### 属性装饰器
```typescript
function MinLength(length: number) {
  return function(target: any, propertyKey: string) {
    let value: string;
    
    const getter = function() { return value; };
    const setter = function(newVal: string) {
      if (newVal.length >= length) {
        value = newVal;
      } else {
        throw new Error(`最小长度: ${length}`);
      }
    };
    
    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter
    });
  };
}

class User {
  @MinLength(3)
  name: string = "";
}
```

#### 参数装饰器
```typescript
function Required(target: any, propertyKey: string, parameterIndex: number) {
  console.log(`参数 ${parameterIndex} 需要检查`);
}

class User {
  setName(@Required name: string) { }
}
```

### 装饰器工厂（带参数）

```typescript
function Validate(min: number, max: number) {
  return function(target: any, propertyKey: string) {
    // 验证逻辑
  };
}

class Product {
  @Validate(0, 100)
  price: number = 50;
}
```

---

## 高级技巧

### Getter 和 Setter

```typescript
class User {
  private _age: number = 0;
  
  get age(): number {
    return this._age;
  }
  
  set age(value: number) {
    if (value < 0) throw new Error("年龄不能为负");
    this._age = value;
  }
}

const user = new User();
user.age = 25; // 调用 setter
console.log(user.age); // 调用 getter
```

### 静态成员

```typescript
class MathUtils {
  static PI = 3.14159;
  
  static distance(x1: number, y1: number, x2: number, y2: number): number {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }
}

console.log(MathUtils.PI);
console.log(MathUtils.distance(0, 0, 3, 4));
```

### 泛型类

```typescript
class Stack<T> {
  private items: T[] = [];
  
  push(item: T): void {
    this.items.push(item);
  }
  
  pop(): T | undefined {
    return this.items.pop();
  }
}

const numStack = new Stack<number>();
numStack.push(1);
const n = numStack.pop(); // 类型: number | undefined
```

### 类型守卫

```typescript
class Shape {
  area(): number { return 0; }
}

class Circle extends Shape {
  radius: number = 1;
  area(): number { return Math.PI * this.radius ** 2; }
}

function showArea(shape: Shape): void {
  if (shape instanceof Circle) {
    console.log("圆形面积:", shape.area());
  } else {
    console.log("形状面积:", shape.area());
  }
}
```

---

## 最佳实践

### ✅ 好的实践

```typescript
// 1. 明确的访问修饰符
class User {
  private id: number;
  public name: string;
  protected role: string;
}

// 2. 使用 readonly
class Config {
  readonly apiUrl: string;
  constructor(url: string) {
    this.apiUrl = url;
  }
}

// 3. 抽象化
abstract class Repository<T> {
  abstract findById(id: number): T | null;
}

// 4. 接口分离原则
interface Readable { read(): void; }
interface Writable { write(): void; }
```

### ❌ 避免的

```typescript
// 1. 过度使用 public
class User {
  public id: number;    // 应该是 private
  public password: string; // 应该是 private
}

// 2. 忘记调用 super
class Child extends Parent {
  constructor() {
    // 忘记了 super()
  }
}

// 3. 深的继承层级（> 3 层）
class A { }
class B extends A { }
class C extends B { }
class D extends C { } // ✗ 太深

// 4. 类中的数据库查询
class User {
  save() {
    // ✗ 混淆了责任
    db.users.insert(this);
  }
}
```

---

## vs Python 对照

### 类定义

```python
# Python
class User:
    def __init__(self, name: str, age: int):
        self.name = name  # 自动属性
        self.age = age
    
    def get_name(self) -> str:
        return self.name
    
    def _private_method(self):  # 约定私有
        pass
```

```typescript
// TypeScript
class User {
  constructor(public name: string, public age: number) {}
  
  getName(): string {
    return this.name;
  }
  
  private privateMethod(): void {}  // 强制私有
}
```

### 继承和 super

```python
# Python
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)
        self.breed = breed
```

```typescript
// TypeScript
class Animal {
  constructor(protected name: string) {}
}

class Dog extends Animal {
  constructor(name: string, public breed: string) {
    super(name);
  }
}
```

### 装饰器

```python
# Python
from functools import wraps

def log(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"调用 {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

class User:
    @log
    def get_name(self):
        return "张三"
```

```typescript
// TypeScript (需要启用 experimentalDecorators)
function Log(target: any, key: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  descriptor.value = function(...args: any[]) {
    console.log(`调用 ${key}`);
    return original.apply(this, args);
  };
}

class User {
  @Log
  getName() {
    return "张三";
  }
}
```

---

## 常见错误和解决

| 错误 | 原因 | 解决 |
|-----|------|------|
| Property undefined | 忘记初始化 | 在构造函数中初始化 |
| Cannot access private | 访问私有成员 | 改为 public/protected |
| Missing super() | 子类没调用 super | 添加 super() |
| Cannot instantiate abstract | 实例化抽象类 | 创建具体子类 |

---

## 参考资源

- TypeScript Handbook: Classes
- OOP 设计原则 (SOLID)
- Design Patterns in TypeScript
- 装饰器提案: https://github.com/tc39/proposal-decorators
